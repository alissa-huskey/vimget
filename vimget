#!/usr/bin/env bash
#
# vimget -- like wget for vim plugins
# shellcheck disable=SC2059

# {{{ bash options

set -Eeo pipefail # fail on errors, even within pipes
shopt -s xpg_echo  # expand backslash escapes in echo automatically (ie \n)

read -r errfile < <(mktemp)

# }}} /bash options

# signal trapping {{{
#

vg:handle_err() {
  local trapped_code="$?"
  if [[ ! "$trapped_code" =~ ^[$code_env|$code_usr]$ ]]; then
    vg:err "ERROR: $trapped_code"
    vg:trace
    exit $code_err
  fi
}

trap vg:handle_err ERR
trap 'rm $errfile' EXIT

#
# }}} / signal trapping

# {{{ global variables

__me="${0##*/}"
__args=( "${@}" )

# }}} / global variables

# usage {{{
#

usage() {
  local -i code=${1}
  [[ -z "$code" ]] && code=${code_suc} || :

cat <<HELPTEXT
usage: ${__me} [-q|-V] [-n] [-d] <repo url>
options:
  -d | --dry-run
  -n | --no-color
  -q | --quiet
  -V | --verbose

${__me} ${version} -- like wget for vim plugins
HELPTEXT

  exit $code
}

#
# }}} / usage

# error handling {{{
#

vg:trace() {
  local frame=0 line file func

  while read -r line func file < <(caller $frame); do
    if [[ -z "${file}" ]]; then
      file="${func}"
      printf "%s:%s\n" "${file##*/}" "${line}"
    else
      printf "%s:%s in %s()\n" "${file##*/}" "${line}" "${func}"
    fi
    ((frame++));
  done
}

vg:err() {
  local line header="Error:" i=0

  for line in "${@}"; do
    [[ $i -gt 0 ]] && header="     >" || :

    vg:printfx -c red -n "${header}" -r -p " ${line}" >&2
    : $(( i++ ))
  done
}

vg:die() {
  local -i code=${1} ; shift

  if [[ $# -gt 0 ]]; then
    vg:err "${@}"
  fi

  vg:print_errfile red grey 1

  exit $code
}

#
# }}} / error handling

# environment checking {{{
#

vg:has() {
  for pkg in "${@}"; do
    if command -v "${pkg}" > /dev/null; then
      return
    fi
  done

  return 1
}

vg:require_vim() {
  if ! vg:has vim nvim; then
    vg:die $code_env "vim not found"
  fi
}

vg:require_git() {
  if ! vg:has git; then
    vg:die $code_env "git not found"
  fi
}

vg:find_duplicates() {
  if [[ -e "${target_path}" ]]; then
    vg:die $code_env "Plugin already installed at:" "${target_path}"
  fi

  return 0
}

vg:check_env() {
  home_dir="$(cd -P $HOME && printf "%s" "$PWD")"

  vg:require_git
  vg:require_vim
  vg:find_vimdir
  vg:find_plugins_dir
}

vg:find_plugins_dir() {
  local dir
  local -a dirs=(                            \
      "${VIM_PLUGINS_DIR:-#}"                \
      "${user_vimdir:-#}/bundle"             \
      "${user_vimdir:-#}/pack/start/bundle"  \
  )

  for dir in "${dirs[@]}"; do
    if cd -P ${dir} 2> /dev/null; then
      vim_plugins_dir="${PWD}"
      break
    fi
  done

  # shellcheck disable=SC2153
  if [[ -n "${VIM_PLUGINS_DIR}" ]] && [[ "${VIM_PLUGINS_DIR}" != "${dir}" ]]; then
    vg:die ${code_env} "Unable to access provided VIM_PLUGINS_DIR:" \
      "${VIM_PLUGINS_DIR}"
  fi


  if [[ -z "${vim_plugins_dir}" ]]; then
    vg:die ${code_env} "Unable to find plugins dir." \
      "Please set the environment variable VIM_PLUGINS_DIR to continue."
  fi

  vg:config "plugins-dir" "${vim_plugins_dir}"
}

vg:find_vimdir() {
  local dir
  # the :-# pattern replaces any empty variables with "#"
  # to avoid any unexpected behavior /paths
  local -a dirs=(                       \
      "${VIMDIR:-#}"                    \
      "${HOME:-#}/.vim"                 \
      "${HOME:-#}/vimfiles"             \
      "${HOME:-#}/config/nvim"          \
      "${HOME:-#}/AppData/Local/nvim"   \
      "${XDG_CONFIG_HOME:-#}/nvim"      \
  )

  for dir in "${dirs[@]}"; do
    if cd -P "${dir}" 2> /dev/null; then
      user_vimdir="${PWD}"
      break
    fi
  done

  if [[ -n "${VIMDIR}" ]] && [[ "${VIMDIR}" != "${dir}" ]]; then
    vg:die ${code_env} "Unable to access provided VIMDIR:" \
      "${VIMDIR}"
  fi

  if [[ -z "${user_vimdir}" ]]; then
    vg:die ${code_env} "Unable to find vimdir." \
      "Please set the environment variable VIMDIR to continue."
  fi

  vg:config "vimdir" "${user_vimdir}"
}

#
# }}} / environment checking

# printing output {{{
#

vg:color() {
  [[ ! "$TERM" =~ color ]] && return || :
  [[ "${color_mode}" == "off" ]] && return || :

  local color="${1}" code=""

  case "${color}" in
    red)              code='31'   ;;
    green)            code='32'   ;;
    yellow)           code='33'   ;;
    blue)             code='34'   ;;
    magenta)          code='35'   ;;
    cyan)             code='36'   ;;
    grey)             code='90'   ;;
    bright-red)       code='91'   ;;
    bright-green)     code='92'   ;;
    bright-yellow)    code='93'   ;;
    bright-blue)      code='94'   ;;
    bright-magenta)   code='95'   ;;
    bright-cyan)      code='96'   ;;
    reset)            code='39'   ;;
  esac

  printf "\033[${code}m"
}

vg:msg() {
  if [[ ${quiet_mode} ]]; then
    return
  fi

  vg:printfx "$@"
}

# colorize and format output
# -c <color>  -- print the following string(s) in color
# -n <string> -- don't print a newline after <string>
# printfx <string>
# printfx -c <color> <sring>
# printfx <string> <string> -c color <string> <string>
# printfx -c <color> -n <string> -c <color> <string>
vg:printfx() {
  local colored

  while [[ $# -ne 0 ]]; do
    case $1 in
      -c)
        if [[ "$2" == "reset" ]]; then
          colored=
        else
          colored="${2}"
        fi
        vg:color "${2}"
        shift
        ;;
      -n)
        printf "%s" "${2}"
        shift
        ;;
      -p)
        vg:pretty_paths "${2}"
        printf "\n"
        shift
        ;;
      -r)
        colored=
        vg:color reset
        ;;
      *)
        printf "%s\n" "${1}"
        ;;
    esac
    shift
  done

  if [[ -n "${colored}" ]]; then
    vg:color reset
  fi
}

vg:config() {
  [[ ! ${verbose_mode} ]] && return || :

  local name="${1}" val="${2}" width1=12 width2=50 str

  read -r str < <( vg:pretty_paths "${val}" ) || :

  vg:printfx -c bright-blue -n "|"
  printf " %-*s " ${width1} "${name}"
  vg:printfx -c bright-blue -n "|"
  printf " %-*s " ${width2} "${str}"
  vg:printfx -c bright-blue "|"
}

vg:success() {
  if [[ $dryrun_mode ]] || [[ $quiet_mode ]]; then
    return
  fi

  vg:msg -c green -n "[SUCCESS]" -r -n " Plugin installed at: " -p "${target_path}"
  printf "\n"
}

vg:debug() {
  vg:printfx -c yellow -n "DEBUG:" -c reset  -n " " "${@}"
}

vg:pretty_paths() {
  local i str="$1" path shorthand

  local -a paths=(                                 \
    "${vim_plugins_dir}" '$VIM_PLUGINS_DIR'        \
    "${user_vimdir}"     '$VIMDIR'                 \
    "${user_pwd}"        '.'                       \
    "${HOME}"            '~'                       \
    "${TMPDIR%/}"        '$TMPDIR'                 \
  )

  for(( i=0; i < ${#paths[@]}; i+=2 )); do
    path="${paths[$i]}"
    shorthand="${paths[((i+1))]}"

    if [[ "${str}" == "$path" ]]; then
      continue
    fi
    str="${str/$path/$shorthand}"
  done

  printf "%s" "${str}"
}

#
# }}} / printing output

# parsing input {{{
#

#  */<name>.git
vg:dot_git_uri_matcher() {
  sed -nE 's/^.*\/([^/]+).git[/]?$/\1/p' <<< "$1"
}

# *github.com/*/<name>
vg:github_uri_matcher() {
  sed -nE 's/^.*github\.com\/[^/]+\/([^/]+)[/]?$/\1/p' <<< "$1"
}

# git://.*/(<name>)
vg:git_scheme_uri_matcher() {
  sed -nE 's/^git:\/\/.+\/([^/]+)[/]?$/\1/p'<<< "${1#/}"
}

# <owner>/<name>
vg:github_shorthand_uri_matcher() {
  sed -nE 's/^[^/]+\/([^/]+)$/\1/p'<<< "${1#/}"
}

# parse - parse the plugin name from the repo uri
#         and set global variables
# usage: parse <url>
vg:parse_uri() {
  local input="${1}" name

  for fun in dot_git github git_scheme github_shorthand; do
    read -r name < <("vg:${fun}_uri_matcher" "${input}") || :
    if [[ -n "${name}" ]]; then
      break
    fi
  done

  if [[ -z "$name" ]]; then
    vg:die ${code_usr} "Unable to recognize URI: '${input}'." \
      "Expecting something that looks like *.git, *github.com* or git://*"
  fi

  uri="${input}"
  target_path="${vim_plugins_dir}/${name}"

  if [[ "$fun" == "github_shorthand" ]]; then
    uri="https://github.com/${uri}"
  fi

  vg:config "plugin-uri" "${uri}"
  vg:config "plugin-name" "${name}"
  vg:config "target-dir" "${target_path}"
}

# split -xyz into -x -y -z
#   saves results to args()
vg:split_shortargs() {
  local arg
  while [[ $# -ne 0 ]]; do
    arg="$1"
    if [[ "$arg" =~ ^-[a-zA-Z]+$ ]]; then
      while read -rn 1; do
        [[ ${#REPLY} -gt 0 ]] && args+=("-${REPLY}") || :
       done  <<< "${arg#-}"
    else
      args+=( "${arg}" )
    fi
    shift
  done
}

vg:handle_args() {
  [[ $# -eq 0 ]] && usage ${code_usr} || :

  local arg

  while [[ $# -ne 0 ]]; do
    arg="$1"
    case "${arg}" in
      ''|-h*|--h*|help)
        usage
        ;;
      -d|--dry-run)
        dryrun_mode="on"
        ;;
      -n|--no-color)
        color_mode="off"
        ;;
      -q|--quiet)
        quiet_mode="true"
        ;;
      -V|--verbose)
        verbose_mode="true"
        ;;
      *)
        if [[ -z "${source}" ]]; then
          source="${arg}"
        else
          vg:err "invalid argument(s)"
          usage ${code_usr}
        fi
        ;;
    esac
    shift
  done

  if [[ ${NO_COLOR} ]]; then
    color_mode="off"
  fi

  if [[ ${verbose_mode} ]]; then
    quiet_mode=
  fi
}

#
# }}} / parsing input

# job management {{{
#

vg:run() {
  local ec cmd

  vg:msg -c grey -p "> ${*}"

  if [[ $dryrun_mode ]]; then
    return
  fi

  "${@}" 2> "${errfile}" || ec=$?

  if [[ $ec -ne 0 ]]; then
    vg:die ${code_fail} "[$?] Command failed:" "${*}"
  else
    vg:print_errfile grey grey
  fi
}

vg:print_errfile() {
  if [[ ! -s "$errfile" ]]; then
    return
  fi

  local spacer_color="$1" text_color="$2" force=$3

  if [[ ${quiet_mode} ]] && [[ ! ${force} ]]; then
    return
  fi

  # append a line in case the last line didn't
  echo >> "${errfile}"

  while read -r line; do
    # skip blank lines
    if [[ -z "${line// /}" ]]; then
      continue
    fi

    vg:printfx -c "${spacer_color}" -n "| " -c "${text_color}" "$line"
  done < "${errfile}"

  # clear the file
  echo > "${errfile}"
}

vg:fetch_plugin() {
  local noise_flag=""
  [[ -n "${quiet_mode}" ]] && noise_flag="--quiet" || :
  [[ -n "${verbose_mode}" ]] && noise_flag="--verbose" || :

  vg:run cd "${vim_plugins_dir}" && \
    vg:run git clone ${noise_flag} --depth 1 "${uri}"
}

vg:helptags() {
  if [[ $dryrun_mode ]]; then
    return
  fi

  while IFS= read -r -d $'\0' docpath ; do

    # -E -s   -- run in Ex mode but with "Entering Ex mode" messages silenced
    # -C      -- run in compatible mode -- suppresses escape codes
    # -u NONE -- like --clean but works for older vim versions
    # -c redir >> ${errfile} -- appends any vim errors to our error file
    vg:run vim -E -s -C -u NONE -c "redir >> ${errfile}" -c "helptags "${docpath} -c 'q'

    if [[ ! -e "${docpath}/tags" ]]; then
      vg:die $code_fail ":helptags failed for path:" "${docpath}"
    fi

  done < <( find ${target_path} -type d -name doc -print0 )
}

#
# }}} / job management

main() {
  local color_mode=on dryrun_mode quiet_mode verbose_mode  # modes
  local user_vimdir vim_plugins_dir home_dir               # found or assigned paths
  local source args=()                                     # input
  local uri name target_path                               # final plugin details

  local version='0.2'
  local user_pwd="${PWD}"

  # exit codes
  local code_suc=0      # success
  local code_err=1      # error
  local code_env=102    # missing requirement
  local code_usr=103    # invalid input
  local code_fail=104   # external command failure

  vg:split_shortargs "${__args[@]}"
  vg:handle_args "${args[@]}"
  vg:check_env

  vg:parse_uri "${source}"

  vg:find_duplicates
  vg:fetch_plugin
  vg:helptags
  vg:success

  return ${code_suc}
}

main
