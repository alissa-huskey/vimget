#!/usr/bin/env bash
#
# vimget -- like wget for vim plugins
# shellcheck disable=SC2059

# {{{ bash options

set -Eeo pipefail # fail on errors, even within pipes
shopt -s xpg_echo  # expand backslash escapes in echo automatically (ie \n)

# }}} /bash options

# signal trapping {{{
#

vg:handle_err() {
  local trapped_code="$?"
  if [[ ! "$trapped_code" =~ ^[$code_env|$code_usr]$ ]]; then
    vg:err "ERROR: $trapped_code"
    vg:trace
    exit $code_err
  fi
}

trap vg:handle_err ERR

#
# }}} / signal trapping

# {{{ global variables

__me="${0##*/}"
__args=( "${@}" )

# }}} / global variables

# usage {{{
#

usage() {
  local -i code=${1}
  [[ -z "$code" ]] && code=${code_suc} || :

cat <<HELPTEXT
usage: ${__me} [-q|-n|-d-q] <repo url>
options:
  -n | --no-color
  -d | --dry-run
  -q | --quiet
  -V | --verbose

${__me} ${version} -- like wget for vim plugins
HELPTEXT

  exit $code
}

#
# }}} / usage

# error handling {{{
#

vg:trace() {
  local frame=0 line file func

  while read -r line func file < <(caller $frame); do
    if [[ -z "${file}" ]]; then
      file="${func}"
      printf "%s:%s\n" "${file##*/}" "${line}"
    else
      printf "%s:%s in %s()\n" "${file##*/}" "${line}" "${func}"
    fi
    ((frame++));
  done
}

vg:err() {
  local line header="Error:" i=0

  for line in "${@}"; do
    [[ $i -gt 0 ]] && header="     >" || :

    vg:printfx -c red -n "${header}" -c reset " ${line}" >&2
    : $(( i++ ))
  done
}

vg:die() {
  local -i code=${1} ; shift

  if [[ $# -gt 0 ]]; then
    vg:err "${@}"
  fi

  exit $code
}

#
# }}} / error handling

# environment checking {{{
#

vg:has() {
  for pkg in "${@}"; do
    if command -v "${pkg}" > /dev/null; then
      return
    fi
  done

  return 1
}

vg:require_vim() {
  if ! vg:has vim nvim; then
    vg:die $code_env "vim not found"
  fi
}

vg:require_git() {
  if ! vg:has git; then
    vg:die $code_env "git not found"
  fi
}

vg:find_duplicates() {
  if [[ -e "${target_path}" ]]; then
    vg:die $code_env "Plugin already installed at:" "${target_path}"
  fi

  return 0
}

vg:check_env() {
  home_dir="$(cd -P $HOME && printf "%s" "$PWD")"
  vg:require_git
  vg:require_vim
  vg:find_vimdir
  vg:find_plugins_dir
}

vg:find_plugins_dir() {
  local dir
  local -a dirs=(                            \
      "${VIM_PLUGINS_DIR:-#}"                \
      "${user_vimdir:-#}/bundle"             \
      "${user_vimdir:-#}/pack/start/bundle"  \
  )

  for dir in "${dirs[@]}"; do
    if cd -P ${dir} 2> /dev/null; then
      vim_plugins_dir="${PWD}"
      break
    fi
  done

  # shellcheck disable=SC2153
  if [[ -n "${VIM_PLUGINS_DIR}" ]] && [[ "${VIM_PLUGINS_DIR}" != "${dir}" ]]; then
    vg:die ${code_env} "Unable to access provided VIM_PLUGINS_DIR:" \
      "${VIM_PLUGINS_DIR}"
  fi


  if [[ -z "${vim_plugins_dir}" ]]; then
    vg:die ${code_env} "Unable to find plugins dir." \
      "Please set the environment variable VIM_PLUGINS_DIR to continue."
  fi

  vg:config "plugins-dir" "${vim_plugins_dir}" "VIMDIR" "${user_vimdir}"
}

vg:find_vimdir() {
  local dir
  # the :-# pattern replaces any empty variables with "#"
  # to avoid any unexpected behavior /paths
  local -a dirs=(                       \
      "${VIMDIR:-#}"                    \
      "${HOME:-#}/.vim"                 \
      "${HOME:-#}/vimfiles"             \
      "${HOME:-#}/config/nvim"          \
      "${HOME:-#}/AppData/Local/nvim"   \
      "${XDG_CONFIG_HOME:-#}/nvim"      \
  )

  for dir in "${dirs[@]}"; do
    if cd -P "${dir}" 2> /dev/null; then
      user_vimdir="${PWD}"
      break
    fi
  done

  if [[ -n "${VIMDIR}" ]] && [[ "${VIMDIR}" != "${dir}" ]]; then
    vg:die ${code_env} "Unable to access provided VIMDIR:" \
      "${VIMDIR}"
  fi

  if [[ -z "${user_vimdir}" ]]; then
    vg:die ${code_env} "Unable to find vimdir." \
      "Please set the environment variable VIMDIR to continue."
  fi

  vg:config "vimdir" "${user_vimdir}" "HOME" "${HOME:-#}"
}

#
# }}} / environment checking

# printing output {{{
#

vg:color() {
  [[ ! "$TERM" =~ color ]] && return || :
  [[ "${color_mode}" == "off" ]] && return || :

  local color="${1}" code=""

  case "${color}" in
    red)              code='31'   ;;
    green)            code='32'   ;;
    yellow)           code='33'   ;;
    blue)             code='34'   ;;
    magenta)          code='35'   ;;
    cyan)             code='36'   ;;
    grey)             code='90'   ;;
    bright-red)       code='91'   ;;
    bright-green)     code='92'   ;;
    bright-yellow)    code='93'   ;;
    bright-blue)      code='94'   ;;
    bright-magenta)   code='95'   ;;
    bright-cyan)      code='96'   ;;
    reset)            code='39'   ;;
  esac

  printf "\033[${code}m"
}

# colorize and format output
# -c <color>  -- print the following string(s) in color
# -n <string> -- don't print a newline after <string>
# printfx <string>
# printfx -c <color> <sring>
# printfx <string> <string> -c color <string> <string>
# printfx -c <color> -n <string> -c <color> <string>
vg:printfx() {
  [[ -n "${quiet_mode}" ]] && return 0
  local color_code="" toggle

  while [[ $# -ne 0 ]]; do
    case $1 in
      -c)
        if [[ ! ${toggle} ]]; then
          toggle="on"
          vg:color "${2}"
        else
          toggle=
          vg:color reset
          vg:color "${2}"
        fi
        shift
        ;;
      -n)
        printf "${2}"
        shift
        ;;
      *)
        printf "${1}\n"
        ;;
    esac
    shift
  done

  [[ "${toggle}" == "on" ]] && vg:color reset || :
}

vg:config() {
  [[ ! ${verbose_mode} ]] && return || :

  local name="${1}" val="${2}" pathname='$'"${3}" path="${4}"
  local width1=12 width2=50 sep

  vg:printfx -c bright-blue -n "|"
  printf " %-*s " ${width1} "${name}"
  vg:printfx -c bright-blue -n "|"
  printf " %-*s " ${width2} "${val/$path/$pathname}"
  vg:printfx -c bright-blue "|"
}

vg:success() {
  if [[ $dryrun_mode ]]; then
    return
  fi

  vg:printfx -c green "[SUCCESS]" -c reset " Plugin installed at ${target_path}"
}

vg:debug() {
  vg:printfx -c yellow -n "DEBUG:" -c reset  -n " " "${@}"
}

#
# }}} / printing output

# parsing input {{{
#

#  */<name>.git
vg:dot_git_uri_matcher() {
  sed -nE 's/^.*\/([^/]+).git[/]?$/\1/p' <<< "$1"
}

# *github.com/*/<name>
vg:github_uri_matcher() {
  sed -nE 's/^.*github\.com\/[^/]+\/([^/]+)[/]?$/\1/p' <<< "$1"
}

# git://.*/(<name>)
vg:git_scheme_uri_matcher() {
  sed -nE 's/^git:\/\/.+\/([^/]+)[/]?$/\1/p'<<< "${1#/}"
}

# <owner>/<name>
vg:github_shorthand_uri_matcher() {
  sed -nE 's/^[^/]+\/([^/]+)$/\1/p'<<< "${1#/}"
}

# parse - parse the plugin name from the repo uri
#         and set global variables
# usage: parse <url>
vg:parse_uri() {
  local input="${1}" name

  for fun in dot_git github git_scheme github_shorthand; do
    read -r name < <("vg:${fun}_uri_matcher" "${input}") || :
    if [[ -n "${name}" ]]; then
      break
    fi
  done

  if [[ -z "$name" ]]; then
    vg:die ${code_usr} "Unable to recognize URI: '${input}'." \
      "Expecting something that looks like *.git, *github.com* or git://*"
  fi

  uri="${input}"
  target_path="${vim_plugins_dir}/${name}"

  if [[ "$fun" == "github_shorthand" ]]; then
    uri="https://github.com/${uri}"
  fi

  vg:config "plugin-uri" "${uri}"
  vg:config "plugin-name" "${name}"
  vg:config "target-dir" "${target_path}" "VIM_PLUGINS_DIR" "${vim_plugins_dir}"
}

# split -xyz into -x -y -z
#   saves results to args()
vg:split_shortargs() {
  local arg
  while [[ $# -ne 0 ]]; do
    arg="$1"
    if [[ "$arg" =~ ^-[a-zA-Z]+$ ]]; then
      while read -rn 1; do
        [[ ${#REPLY} -gt 0 ]] && args+=("-${REPLY}") || :
       done  <<< "${arg#-}"
    else
      args+=( "${arg}" )
    fi
    shift
  done
}

vg:handle_args() {
  [[ $# -eq 0 ]] && usage ${code_usr} || :

  local arg

  while [[ $# -ne 0 ]]; do
    arg="$1"
    case "${arg}" in
      ''|-h*|--h*|help)
        usage
        ;;
      -d|--dry-run)
        dryrun_mode="on"
        ;;
      -n|--no-color)
        color_mode="off"
        ;;
      -q|--quiet)
        quiet_mode="true"
        ;;
      -V|--verbose)
        verbose_mode="true"
        ;;
      *)
        if [[ -z "${source}" ]]; then
          source="${arg}"
        else
          vg:err "invalid argument(s)"
          usage ${code_usr}
        fi
        ;;
    esac
    shift
  done

  if [[ ${NO_COLOR} ]]; then
    color_mode="off"
  fi
}

#
# }}} / parsing input

# job management {{{
#

vg:run() {
  if [[ $dryrun_mode ]]; then
    vg:printfx -c grey "> ${*}"
    return
  fi

  "${@}" || vg:die $code_fail "Command failed: ${*}"
}

vg:fetch_plugin() {
  local flag=""
  [[ -n "${quiet_mode}" ]] && flag=" --quiet"

  vg:run cd "${vim_plugins_dir}"

  vg:color grey
  vg:run git clone ${flag} --depth 1 "${uri}"
  vg:color reset
}

vg:helptags() {
  if [[ $dryrun_mode ]]; then
    return
  fi

  while IFS= read -r -d $'\0' docpath ; do
    vg:run vim -e -c ":helptags ${docpath}" -c ':q'
  done < <( find ${target_path} -type d -name doc -print0 )
}

#
# }}} / job management

main() {
  local color_mode=on dryrun_mode quiet_mode verbose_mode  # modes
  local user_vimdir vim_plugins_dir home_dir               # found or assigned paths
  local source args=()                                     # input
  local uri name target_path                               # final plugin details

  local version='0.2'

  # exit codes
  local code_suc=0      # success
  local code_err=1      # error
  local code_env=102    # missing requirement
  local code_usr=103    # invalid input
  local code_fail=104   # external command failure

  vg:split_shortargs "${__args[@]}"
  vg:handle_args "${args[@]}"
  vg:check_env

  vg:parse_uri "${source}"

  vg:find_duplicates
  vg:fetch_plugin
  vg:helptags
  vg:success

  return ${code_suc}
}

main
